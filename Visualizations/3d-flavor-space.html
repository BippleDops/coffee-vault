<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flavor Space - Coffee Vault 7.0</title>

    <!-- Shared Infrastructure -->
    <link rel="stylesheet" href="shared-styles.css">
    <script src="shared-controls.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e8e8e8;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(139, 69, 19, 0.3);
            z-index: 10;
            max-width: 300px;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #d4a574;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #b8b8b8;
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e8e8e8;
            font-size: 13px;
        }
        
        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(139, 69, 19, 0.3);
            z-index: 10;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(139, 69, 19, 0.3);
            z-index: 10;
            max-width: 250px;
            font-size: 13px;
            display: none;
        }
        
        #info h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #d4a574;
        }
        
        #info p {
            margin-bottom: 5px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- Accessibility skip link -->
    <a href="#canvas" class="cv-skip-link">Skip to visualization</a>

    <!-- Unified Control Panel -->
    <div id="cv-control-panel-container"></div>

    <div id="container" role="main" aria-label="3D Flavor Space Visualization">
        <canvas id="canvas" role="img" aria-label="Interactive 3D flavor space showing coffee characteristics" aria-describedby="flavor-desc"></canvas>
    </div>

    <!-- Accessibility description -->
    <div id="flavor-desc" class="cv-sr-only">
        This 3D visualization maps coffee flavors in a three-dimensional space.
        Each sphere represents a coffee bean with position determined by flavor characteristics like acidity, body, and sweetness.
        Use arrow keys to rotate, plus/minus to zoom, and mouse to interact.
    </div>

    <div id="controls" style="display: none;">
        <h1>☕ 3D Flavor Space</h1>
        
        <div class="control-group">
            <label>X-Axis</label>
            <select id="x-axis">
                <option value="acidity">Acidity</option>
                <option value="body">Body</option>
                <option value="sweetness">Sweetness</option>
                <option value="complexity">Complexity</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Y-Axis</label>
            <select id="y-axis">
                <option value="body">Body</option>
                <option value="acidity">Acidity</option>
                <option value="sweetness">Sweetness</option>
                <option value="complexity">Complexity</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Z-Axis</label>
            <select id="z-axis">
                <option value="sweetness" selected>Sweetness</option>
                <option value="acidity">Acidity</option>
                <option value="body">Body</option>
                <option value="complexity">Complexity</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Color By</label>
            <select id="color-by">
                <option value="origin">Origin</option>
                <option value="roast">Roast Level</option>
                <option value="processing">Processing</option>
                <option value="rating">Rating</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Filter</label>
            <select id="filter">
                <option value="all">All Beans</option>
                <option value="favorites">Favorites Only</option>
                <option value="high-rated">High Rated (4.5+)</option>
                <option value="recent">Recent Purchases</option>
            </select>
        </div>
    </div>
    
    <div id="legend">
        <div class="legend-item">
            <div class="color-box" style="background: #ff6b6b;"></div>
            <span>Ethiopia</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background: #4ecdc4;"></div>
            <span>Colombia</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background: #ffe66d;"></div>
            <span>Kenya</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background: #a8e6cf;"></div>
            <span>Guatemala</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background: #ff8b94;"></div>
            <span>Brazil</span>
        </div>
    </div>
    
    <div id="info">
        <h3 id="info-name">Bean Name</h3>
        <p><strong>Origin:</strong> <span id="info-origin"></span></p>
        <p><strong>Processing:</strong> <span id="info-processing"></span></p>
        <p><strong>Roast:</strong> <span id="info-roast"></span></p>
        <p><strong>Rating:</strong> <span id="info-rating"></span></p>
        <p><strong>Flavors:</strong> <span id="info-flavors"></span></p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================================================
        // INITIALIZATION - Load real data from Coffee Vault
        // ============================================================================

        let allCoffeeLogs = [];
        let currentData = [];
        let controlPanel = null;

        // Initialize visualization
        async function initVisualization() {
            LoadingStateManager.showLoading(
                document.getElementById('container'),
                'Loading your coffee data...'
            );

            try {
                // Load real coffee log data
                allCoffeeLogs = await DataLoader.loadCoffeeLogs();

                // Initialize control panel
                controlPanel = new StandardControlPanel('cv-control-panel-container', {
                    title: '3D Flavor Space Controls',
                    filters: ['time', 'method', 'rating', 'origin'],
                    export: true,
                    theme: true,
                    customControls: [
                        {
                            id: 'x-axis',
                            label: 'X-Axis',
                            type: 'select',
                            options: [
                                { value: 'acidity', label: 'Acidity' },
                                { value: 'body', label: 'Body' },
                                { value: 'sweetness', label: 'Sweetness' },
                                { value: 'complexity', label: 'Complexity' }
                            ]
                        },
                        {
                            id: 'y-axis',
                            label: 'Y-Axis',
                            type: 'select',
                            options: [
                                { value: 'body', label: 'Body' },
                                { value: 'acidity', label: 'Acidity' },
                                { value: 'sweetness', label: 'Sweetness' },
                                { value: 'complexity', label: 'Complexity' }
                            ]
                        },
                        {
                            id: 'z-axis',
                            label: 'Z-Axis',
                            type: 'select',
                            options: [
                                { value: 'sweetness', label: 'Sweetness' },
                                { value: 'acidity', label: 'Acidity' },
                                { value: 'body', label: 'Body' },
                                { value: 'complexity', label: 'Complexity' }
                            ]
                        }
                    ]
                });

                // Listen for filter changes
                controlPanel.onChange((filters) => {
                    updateVisualization(filters);
                });

                // Listen for export events
                window.addEventListener('cv-export', () => {
                    ExportManager.showExportDialog({
                        formats: ['png', 'csv'],
                        onExport: (format) => {
                            if (format === 'png') {
                                const canvas = document.querySelector('canvas');
                                ExportManager.exportPNG(canvas, '3d-flavor-space.png');
                            } else if (format === 'csv') {
                                ExportManager.exportCSV(currentData, '3d-flavor-space-data.csv');
                            }
                            AccessibilityHelper.announceToScreenReader('Visualization exported successfully');
                        }
                    });
                });

                // Initial render
                updateVisualization({});

                LoadingStateManager.hideLoading(document.getElementById('container'));

            } catch (error) {
                console.error('Failed to load data:', error);
                LoadingStateManager.showError(
                    document.getElementById('container'),
                    'Failed to load coffee data. Using sample data instead.',
                    () => initVisualization()
                );
            }
        }

        // Update visualization with filtered data
        function updateVisualization(filters) {
            currentData = allCoffeeLogs;

            // Apply filters
            if (filters.timeRange) {
                const cutoff = new Date();
                const days = filters.timeRange === '7days' ? 7 : filters.timeRange === '30days' ? 30 : 90;
                cutoff.setDate(cutoff.getDate() - days);
                currentData = currentData.filter(log => new Date(log.date) >= cutoff);
            }

            if (filters.method) {
                currentData = currentData.filter(log => log.method === filters.method);
            }

            if (filters.minRating) {
                currentData = currentData.filter(log => log.rating >= filters.minRating);
            }

            if (filters.origin) {
                currentData = currentData.filter(log => log.origin === filters.origin);
            }

            if (currentData.length === 0) {
                LoadingStateManager.showEmpty(
                    document.querySelector('#legend'),
                    'No coffee logs match the selected filters'
                );
                return;
            }

            // Recreate scene with filtered data
            createScene(currentData);
            AccessibilityHelper.announceToScreenReader(`Showing ${currentData.length} coffee logs`);
        }
        
        // Color palettes
        const originColors = {
            'Ethiopia': 0xff6b6b,
            'Colombia': 0x4ecdc4,
            'Kenya': 0xffe66d,
            'Guatemala': 0xa8e6cf,
            'Brazil': 0xff8b94
        };
        
        const roastColors = {
            'light': 0xd4a574,
            'medium': 0x8b5a3c,
            'medium-dark': 0x5c3d2e,
            'dark': 0x3a2418
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Add grid
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Add axes with enhanced visibility
        const axesHelper = new THREE.AxesHelper(12);
        scene.add(axesHelper);
        
        // Add axis labels with improved visibility
        function createTextSprite(message, color = 0xFFD700, size = 40) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            // Background for better readability
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Text
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = `Bold ${size}px Arial`;
            context.textAlign = 'center';
            context.fillText(message, canvas.width / 2, canvas.height / 2 + size / 3);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(6, 1.5, 1);
            return sprite;
        }
        
        // Add axis labels (will be positioned dynamically)
        let axisLabels = {
            xPositive: createTextSprite('Acidity →', 0xFF8F00),
            xNegative: createTextSprite('← Low Acidity', 0xFF8F00),
            yPositive: createTextSprite('Body →', 0x8D6E63),
            yNegative: createTextSprite('← Light Body', 0x8D6E63),
            zPositive: createTextSprite('Sweetness →', 0xD4A574),
            zNegative: createTextSprite('← Low Sweet', 0xD4A574)
        };
        
        function updateAxisLabels() {
            const xAxis = document.getElementById('x-axis').value;
            const yAxis = document.getElementById('y-axis').value;
            const zAxis = document.getElementById('z-axis').value;
            
            // Remove old labels
            Object.values(axisLabels).forEach(label => scene.remove(label));
            
            // Create new labels with current axis names
            axisLabels.xPositive = createTextSprite(`High ${xAxis.charAt(0).toUpperCase() + xAxis.slice(1)} →`, 0xFF8F00);
            axisLabels.xNegative = createTextSprite(`← Low ${xAxis.charAt(0).toUpperCase() + xAxis.slice(1)}`, 0xFF8F00);
            axisLabels.yPositive = createTextSprite(`High ${yAxis.charAt(0).toUpperCase() + yAxis.slice(1)} →`, 0x8D6E63);
            axisLabels.yNegative = createTextSprite(`← Low ${yAxis.charAt(0).toUpperCase() + yAxis.slice(1)}`, 0x8D6E63);
            axisLabels.zPositive = createTextSprite(`High ${zAxis.charAt(0).toUpperCase() + zAxis.slice(1)} →`, 0xD4A574);
            axisLabels.zNegative = createTextSprite(`← Low ${zAxis.charAt(0).toUpperCase() + zAxis.slice(1)}`, 0xD4A574);
            
            // Position labels
            axisLabels.xPositive.position.set(12, 0, 0);
            axisLabels.xNegative.position.set(-12, 0, 0);
            axisLabels.yPositive.position.set(0, 12, 0);
            axisLabels.yNegative.position.set(0, -12, 0);
            axisLabels.zPositive.position.set(0, 0, 12);
            axisLabels.zNegative.position.set(0, 0, -12);
            
            // Add to scene
            Object.values(axisLabels).forEach(label => scene.add(label));
        }
        
        // Initialize axis labels
        updateAxisLabels();
        
        // Create data points
        const points = [];
        const pointMeshes = [];
        
        function createScene(data) {
            // Clear existing points
            pointMeshes.forEach(mesh => scene.remove(mesh));
            pointMeshes.length = 0;

            const xAxis = document.getElementById('cv-custom-x-axis')?.value || 'acidity';
            const yAxis = document.getElementById('cv-custom-y-axis')?.value || 'body';
            const zAxis = document.getElementById('cv-custom-z-axis')?.value || 'sweetness';
            const colorBy = 'origin'; // Color by origin for now
            
            data.forEach(bean => {
                const x = (bean[xAxis] - 5) * 2;
                const y = (bean[yAxis] - 5) * 2;
                const z = (bean[zAxis] - 5) * 2;
                
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const color = colorBy === 'origin' ? originColors[bean.origin] :
                             colorBy === 'roast' ? roastColors[bean.roast] :
                             0xd4a574;
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                sphere.userData = bean;
                
                scene.add(sphere);
                pointMeshes.push(sphere);
            });
        }
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('click', onClick);
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes);
            
            if (intersects.length > 0) {
                const bean = intersects[0].object.userData;
                showInfo(bean);
                document.body.style.cursor = 'pointer';
            } else {
                hideInfo();
                document.body.style.cursor = 'default';
            }
        }
        
        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes);
            
            if (intersects.length > 0) {
                const bean = intersects[0].object.userData;
                console.log('Selected bean:', bean);
            }
        }
        
        function showInfo(bean) {
            const info = document.getElementById('info');
            info.style.display = 'block';
            
            document.getElementById('info-name').textContent = bean.name;
            document.getElementById('info-origin').textContent = bean.origin;
            document.getElementById('info-processing').textContent = bean.processing;
            document.getElementById('info-roast').textContent = bean.roast;
            document.getElementById('info-rating').textContent = `${bean.rating}⭐`;
            document.getElementById('info-flavors').textContent = bean.flavors.join(', ');
        }
        
        function hideInfo() {
            document.getElementById('info').style.display = 'none';
        }
        
        // Camera rotation - configurable
        let autoRotate = false; // DEFAULT: OFF (user can enable)
        let rotationSpeed = 0.001;
        let manualRotation = { x: 0, y: 0 };
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                camera.position.x = Math.cos(Date.now() * rotationSpeed) * 15;
                camera.position.z = Math.sin(Date.now() * rotationSpeed) * 15;
                camera.lookAt(0, 0, 0);
            } else if (manualRotation.x !== 0 || manualRotation.y !== 0) {
                // Manual rotation from mouse drag
                const angle = manualRotation.x;
                const currentX = camera.position.x;
                const currentZ = camera.position.z;
                const radius = Math.sqrt(currentX * currentX + currentZ * currentZ);
                
                camera.position.x = radius * Math.cos(angle);
                camera.position.z = radius * Math.sin(angle);
                camera.position.y += manualRotation.y * 0.1;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Mouse drag controls for manual rotation
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left mouse button
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouse.x;
                const deltaY = e.clientY - previousMouse.y;
                
                manualRotation.x += deltaX * 0.01;
                manualRotation.y += deltaY * 0.01;
                
                previousMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Mouse wheel for zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.5;
            const distance = Math.sqrt(
                camera.position.x ** 2 + 
                camera.position.y ** 2 + 
                camera.position.z ** 2
            );
            
            const newDistance = distance + (e.deltaY > 0 ? zoomSpeed : -zoomSpeed);
            const clampedDistance = Math.max(10, Math.min(30, newDistance));
            
            const scale = clampedDistance / distance;
            camera.position.multiplyScalar(scale);
        });
        
        // Auto-rotate toggle button
        const autoRotateBtn = document.createElement('button');
        autoRotateBtn.textContent = autoRotate ? 'Disable Auto-Rotate' : 'Enable Auto-Rotate';
        autoRotateBtn.style.cssText = `
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #FFD700;
            border-radius: 8px;
            color: #FFD700;
            cursor: pointer;
            font-size: 14px;
            z-index: 20;
        `;
        autoRotateBtn.addEventListener('click', () => {
            autoRotate = !autoRotate;
            autoRotateBtn.textContent = autoRotate ? 'Disable Auto-Rotate' : 'Enable Auto-Rotate';
            autoRotateBtn.style.background = autoRotate ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)';
        });
        document.body.appendChild(autoRotateBtn);
        
        // Help text
        const helpText = document.createElement('div');
        helpText.style.cssText = `
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: #D4A574;
            font-size: 12px;
            z-index: 20;
            max-width: 250px;
        `;
        helpText.innerHTML = `
            <strong style="color: #FFD700;">Controls:</strong><br>
            • Drag to rotate<br>
            • Scroll to zoom<br>
            • Space bar: Toggle auto-rotate<br>
            • Hover over points for details
        `;
        document.body.appendChild(helpText);
        
        // Controls listeners with axis label updates
        document.getElementById('x-axis').addEventListener('change', () => {
            createScene(sampleBeans);
            updateAxisLabels();
        });
        document.getElementById('y-axis').addEventListener('change', () => {
            createScene(sampleBeans);
            updateAxisLabels();
        });
        document.getElementById('z-axis').addEventListener('change', () => {
            createScene(sampleBeans);
            updateAxisLabels();
        });
        document.getElementById('color-by').addEventListener('change', () => createScene(sampleBeans));
        
        // Initialize
        createScene(sampleBeans);
        animate();
        
        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ============================================================================
        // ACCESSIBILITY - Keyboard Navigation
        // ============================================================================

        // Setup keyboard navigation
        AccessibilityHelper.setupKeyboardNav(document.body, {
            'ArrowLeft': () => {
                manualRotation.x -= 0.1;
                AccessibilityHelper.announceToScreenReader('Rotated left');
            },
            'ArrowRight': () => {
                manualRotation.x += 0.1;
                AccessibilityHelper.announceToScreenReader('Rotated right');
            },
            'ArrowUp': () => {
                manualRotation.y += 0.1;
                AccessibilityHelper.announceToScreenReader('Rotated up');
            },
            'ArrowDown': () => {
                manualRotation.y -= 0.1;
                AccessibilityHelper.announceToScreenReader('Rotated down');
            },
            '+': () => {
                const currentDistance = Math.sqrt(
                    camera.position.x ** 2 +
                    camera.position.y ** 2 +
                    camera.position.z ** 2
                );
                const newDistance = Math.max(10, currentDistance - 1);
                const scale = newDistance / currentDistance;
                camera.position.multiplyScalar(scale);
                AccessibilityHelper.announceToScreenReader('Zoomed in');
            },
            '-': () => {
                const currentDistance = Math.sqrt(
                    camera.position.x ** 2 +
                    camera.position.y ** 2 +
                    camera.position.z ** 2
                );
                const newDistance = Math.min(30, currentDistance + 1);
                const scale = newDistance / currentDistance;
                camera.position.multiplyScalar(scale);
                AccessibilityHelper.announceToScreenReader('Zoomed out');
            },
            'r': () => {
                camera.position.set(15, 15, 15);
                camera.lookAt(0, 0, 0);
                manualRotation = { x: 0, y: 0 };
                AccessibilityHelper.announceToScreenReader('View reset');
            },
            ' ': (e) => {
                e.preventDefault();
                autoRotate = !autoRotate;
                autoRotateBtn.textContent = autoRotate ? 'Disable Auto-Rotate' : 'Enable Auto-Rotate';
                autoRotateBtn.style.background = autoRotate ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)';
                AccessibilityHelper.announceToScreenReader(autoRotate ? 'Auto-rotation enabled' : 'Auto-rotation disabled');
            }
        });

        // Initialize visualization on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initVisualization);
        } else {
            initVisualization();
        }
    </script>
</body>
</html>

